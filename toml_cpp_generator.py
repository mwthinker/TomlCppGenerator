#! /usr/bin/env python3
import toml
import argparse
import os

INDENT_STR = '    '

def generate_header(toml_file, namespace="config") -> str:
    header = """
/// This file was autogenerated do not modify it manually.
#ifndef CONFIG_H
#define CONFIG_H

#include <string>
#include <vector>

#include <toml.hpp>

namespace config {
"""
    return header

def generate_bottom() -> str:
    bottom = """}

#endif
"""
    return bottom

def generate_body(name: str, data: dict[str, any], indent: int = 1) -> str:
    """
    Recursively generates C++ struct code from the given TOML data.
    """
    indent_str = INDENT_STR * indent
    struct_code = f"\n{indent_str}struct {name} {{\n"
    
    for key, value in data.items():
        if isinstance(value, dict):
            # Nested table, create a new struct
            struct_code += generate_body(key.capitalize(), value, indent + 1)
            struct_code += f"{indent_str}{INDENT_STR}{key.capitalize()} {key};\n"
        elif isinstance(value, list):
            if all(isinstance(item, dict) for item in value):
                # Array of tables (same structure)
                struct_code += generate_body(key.capitalize(), value[0], indent + 1)
                struct_code += f"{indent_str}{INDENT_STR}std::vector<{key.capitalize()}> {key};\n"
            else:
                # Array of primitive types
                cpp_type = get_cpp_type(value[0])
                struct_code += f"{indent_str}{INDENT_STR}std::vector<{cpp_type}> {key};\n"
        else:
            # Base case: a key-value pair, determine the C++ type
            cpp_type = get_cpp_type(value)
            struct_code += f"{indent_str}{INDENT_STR}{cpp_type} {key};\n"

    # Generate loadFromTOML() function
    struct_code += f"\n{indent_str}    void loadFromTOML(const toml::value& toml_data) {{\n"
    for key, value in data.items():
        if isinstance(value, dict):
            struct_code += f"{indent_str}{indent_str}{key}.loadFromTOML(toml_data.at(\"{key}\"));\n"
        elif isinstance(value, list) and all(isinstance(item, dict) for item in value):
            # Initialize vector of structs
            struct_code += f"{indent_str}        if (toml_data.contains(\"{key}\")) {{\n"
            struct_code += f"{indent_str}            for (const auto& item : toml_data.at(\"{key}\").as_array()) {{\n"
            struct_code += f"{indent_str}                {key}.emplace_back();\n"
            struct_code += f"{indent_str}                {key}.back().loadFromTOML(item);\n"
            struct_code += f"{indent_str}            }}\n"
            struct_code += f"{indent_str}        }}\n"
        else:
            default_value = get_cpp_default_value(value)
            struct_code += f"{indent_str}        if (toml_data.contains(\"{key}\")) {key} = toml_data.at(\"{key}\").as_{get_toml_type(value)}();\n"
            struct_code += f"{indent_str}        else {key} = {default_value};\n"
    struct_code += f"{indent_str}    }}\n"
    
    struct_code += f"{indent_str}}};\n\n"
    return struct_code

def generate_cpp_code(name, toml_data) -> str:
    """
    Generates C++ code from the given TOML data.
    """
    cpp_code = generate_header(name)
    cpp_code += generate_body(name, toml_data, 1)
    cpp_code += generate_bottom()
    return cpp_code

def get_toml_type(value) -> str:
    """
    Returns the corresponding toml11 function type for a given Python value.
    """
    if isinstance(value, int):
        return "integer"
    elif isinstance(value, float):
        return "floating"
    elif isinstance(value, str):
        return "string"
    elif isinstance(value, bool):
        return "boolean"
    else:
        return "value"  # fallback for unsupported types

def get_cpp_type(value) -> str:
    """
    Returns the corresponding C++ type for a given Python value.
    """
    if isinstance(value, int):
        return "int"
    elif isinstance(value, float):
        return "double"
    elif isinstance(value, str):
        return "std::string"
    elif isinstance(value, bool):
        return "bool"
    elif isinstance(value, list):
        return "std::vector"
    else:
        raise ValueError(f"Unsupported type: {type(value)}")
    
def generate_table_initializer(struct_name, table) -> str:
    """
    Generates an initializer list for a C++ struct from a TOML table.
    """
    initializer = f"{struct_name}{{"
    initializer += ", ".join([get_cpp_default_value(value) for value in table.values()])
    initializer += "}"
    return initializer
    
def get_cpp_default_value(value) -> str:
    """
    Returns the default value in C++ syntax for a given Python value.
    """
    if isinstance(value, str):
        return f'"{value}"'
    elif isinstance(value, bool):
        return "true" if value else "false"
    elif isinstance(value, list):
        return "{" + ", ".join(map(str, value)) + "}"
    else:
        return str(value)
    
def load_toml_file(toml_file: str) -> dict[str, any]:
    with open(toml_file, 'r') as file:
        toml_data = toml.load(file)
    return toml_data

def run(args):
    print(os.path.basename(args.toml_file) + " MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM")
    toml_data = load_toml_file(args.toml_file)
    cpp_code = generate_cpp_code("Config", toml_data)
    cpp_file = os.path.join(args.output_dir, os.path.basename(args.toml_file).split(".")[0] + "_config.h")
    with open(cpp_file, "w", encoding="utf-8") as cpp_file:
        cpp_file.write(cpp_code)
    print(f"Generated {cpp_file}")

def main():
    parser = argparse.ArgumentParser(description="Generate C++ code from a TOML file")
    parser.add_argument("toml_file")
    parser.add_argument("output_dir")

    parser.set_defaults(func=run)
    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
